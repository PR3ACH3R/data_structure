What is an algorithm ?

An algorithm is a set of well-defined instructions to solve a particluar problem.
Learning algorithm translates to learning different techniques to solve problems efficiently.


Time and Space Complexity
-------------------------

Time Complexity: It is the computational complexity that describes the amount of computer time it takes to run an algorithm.
Space Complexity: It is the computational complexity that describes the amount of memory space it takes to run an algorithm.

Big O Notation
--------------

The worst case complexity of an algorithm is repesented using Big O notation.


Fibonacci Sequence
------------------
Problem : Give a number n, find the first n elements of the Fibonacci sequence.

In mathematics, the Fibonacci sequence is a series of numbers where a number is the addition of the last two numbers, starting with 0, and 1.
මෙම අනුක්‍රමයේ පළමු සංඛ්‍යා දෙක 0 සහ 1 (විකල්ප වශයෙන් 1 සහ 1) ය. එමෙන්ම, පසුව පැමිණෙන සංඛ්‍යාවක් පෙර සංඛ්‍යා දෙක එකතු කිරීමෙන් ලැබේ. එතැන්පටන් ලැබෙන අනුක්‍රමය මෙසේය 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,

function fibonacci(n: number) {
  const fib = [0, 1];
  for (let i = 2; i < n; i++) {
    fib[i] = fib[i - 1] + fib[i - 2];
  }
  return fib;
}

console.log(fibonacci(2)); // [0,1]
console.log(fibonacci(3)); // [0,1,1]
console.log(fibonacci(7)); // [0,1,1,2,3,5,8]

Big-O = O(n)

Factorial of a Number
----------------------

Problem : Given a number n, find the factorial of n.

ක්‍රමාරෝපිත සංඛ්‍යාව﻿ (factorial number) යනු n! ලෙස නියම කරන ගණිත ක්‍රියාවක් වන අතර, එය 1 සිට n දක්වා ඇති සියලු ධන සංඛ්‍යා එකිනෙකට ගුණ කිරීමෙන් ලැබෙන මුළු එකතුවයි.

තෝරාගත් ඕනෑම පූර්ණ සංඛ්‍යාවක් සඳහා:

n! = n × (n − 1) × (n − 2) × ... × 3 × 2 × 1
factorial(4) = 4 × 3 × 2 × 1 = 24

function factorial(n: number) {
  let result = 1;
  for (let i = 2; i < n; i++) {
    result = result * i;
  }
  return result;
}

console.log(factorial(5)); //24

Prime Numbers
-------------
Problem : Given a number n, determine if the number is prime or not. 

Prime numbers are natural numbers greater than 1 that cannot be formed by multiplying two smaller natural numbers. A prime number is only divisible by 1 and itself.

function isPrime(n: number) {
  if (n <= 1) return false;
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false;
  }
  return true;
}

Recursion
---------
 Recursion is a programming technique where a function calls itself in order to solve a problem. A recursive function typically has two main components: a base case that stops the recursion and a recursive case that continues the recursion.
 
 function recursiveFibonacci(n: number) {
  if (n < 2) {
    return n;
  }
  return recursiveFibonacci(n - 1) + recursiveFibonacci(n - 2);
}

console.log(recursiveFibonacci(0));

Search Algorithms
-----------------
* Linear Search
  Linear search is a simple search algorithm that checks every element in a list sequentially until the desired element is found or the list ends.

Problem: Given an array of n elements and a target element t, find the index of t in the array. Return -1 if the target element is not found.

function linearSearch(arr: number[], traget: number) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === traget) {
      return i;
    }
  }
  return -1;
}
console.log(linearSearch([-5, 2, 10, 4, 6], 10));

* Binary Search
  Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeat until the value is found or the interval is empty.

NOTE: Bineary search can only be applied on sorted arrays.

Steps:
1. Find the middle element of the array.
2. If the middle element is equal to the target element, return the index of the middle element.
3. If the target element is less than the middle element, repeat the search on the left
    half of the array.
4. If the target element is greater than the middle element, repeat the search on the right
    half of the array.

example: arr = [1, 3, 5, 7, 9], target = 7

function binarySearch(arr: number[], target: number) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1; // Target not found
}

With recursion:

function recursiveBinarySearch(arr: number[], target: number) {
  return search(arr, target, 0, arr.length - 1);
}

function search(arr, target, leftIndex, rightIndex) {
  if (leftIndex > rightIndex) {
    return -1;
  }
  let middleIndex = Math.floor((leftIndex + rightIndex) / 2);
  if (target === arr[middleIndex]) {
    return middleIndex;
  }
  if (target < arr[middleIndex]) {
    return search(arr, target, leftIndex, middleIndex - 1);
  } else {
    return search(arr, target, middleIndex + 1, rightIndex);
  }
}

console.log(recursiveBinarySearch([1, 2, 3, 4, 5], 4));
